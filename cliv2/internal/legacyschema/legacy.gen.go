// Package legacyschema provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package legacyschema

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
	externalRef0 "github.com/snyk/cli/cliv2/internal/depgraph"
)

// Defines values for AnnotatedIssueType.
const (
	AnnotatedIssueTypeLicense AnnotatedIssueType = "license"
)

// Defines values for AnnotatedIssueExtraType.
const (
	AnnotatedIssueExtraTypeLicense AnnotatedIssueExtraType = "license"
)

// Defines values for FindingType.
const (
	IacIssue FindingType = "iacIssue"
)

// Defines values for IacProjectTypes.
const (
	Armconfig            IacProjectTypes = "armconfig"
	Cloudformationconfig IacProjectTypes = "cloudformationconfig"
	Customconfig         IacProjectTypes = "customconfig"
	K8sconfig            IacProjectTypes = "k8sconfig"
	Multiiacconfig       IacProjectTypes = "multiiacconfig"
	Terraformconfig      IacProjectTypes = "terraformconfig"
)

// Defines values for Severity.
const (
	Critical Severity = "critical"
	High     Severity = "high"
	Low      Severity = "low"
	Medium   Severity = "medium"
)

// Defines values for SupportedPackageManagers.
const (
	Cocoapods   SupportedPackageManagers = "cocoapods"
	Composer    SupportedPackageManagers = "composer"
	Golangdep   SupportedPackageManagers = "golangdep"
	Gomodules   SupportedPackageManagers = "gomodules"
	Govendor    SupportedPackageManagers = "govendor"
	Gradle      SupportedPackageManagers = "gradle"
	Hex         SupportedPackageManagers = "hex"
	Maven       SupportedPackageManagers = "maven"
	Npm         SupportedPackageManagers = "npm"
	Nuget       SupportedPackageManagers = "nuget"
	Paket       SupportedPackageManagers = "paket"
	Pip         SupportedPackageManagers = "pip"
	Poetry      SupportedPackageManagers = "poetry"
	Rubygems    SupportedPackageManagers = "rubygems"
	Sbt         SupportedPackageManagers = "sbt"
	Swift       SupportedPackageManagers = "swift"
	UnmanagedCC SupportedPackageManagers = "Unmanaged (C/C++)"
	Yarn        SupportedPackageManagers = "yarn"
)

// Defines values for VulnMetaDataType.
const (
	License VulnMetaDataType = "license"
	Vuln    VulnMetaDataType = "vuln"
)

// AffectedPackages defines model for AffectedPackages.
type AffectedPackages map[string]struct {
	Issues *map[string]Issue `json:"issues,omitempty"`
	Pkg    *Pkg              `json:"pkg,omitempty"`
}

// Analytics defines model for Analytics.
type Analytics struct {
	Data *map[string]interface{} `json:"data,omitempty"`
	Name *string                 `json:"name,omitempty"`
}

// AnnotatedIssue defines model for AnnotatedIssue.
type AnnotatedIssue struct {
	Filename          *string                 `json:"__filename"`
	Below             *string                 `json:"below,omitempty"`
	Bundled           *map[string]interface{} `json:"bundled"`
	Credit            *[]string               `json:"credit,omitempty"`
	CvssScore         *float32                `json:"cvssScore"`
	Description       *string                 `json:"description,omitempty"`
	FixedIn           *[]string               `json:"fixedIn,omitempty"`
	From              *[]string               `json:"from,omitempty"`
	Id                *string                 `json:"id,omitempty"`
	Identifiers       *map[string][]string    `json:"identifiers,omitempty"`
	IsNew             *bool                   `json:"isNew,omitempty"`
	IsPatchable       *bool                   `json:"isPatchable,omitempty"`
	IsUpgradable      *bool                   `json:"isUpgradable,omitempty"`
	LegalInstructions *string                 `json:"legalInstructions"`
	LineNumber        *int                    `json:"lineNumber"`
	ModuleName        *string                 `json:"moduleName"`
	Name              *string                 `json:"name,omitempty"`
	Note              *string                 `json:"note"`
	OriginalSeverity  *Severity               `json:"originalSeverity,omitempty"`
	PackageManager    *SupportedProjectTypes  `json:"packageManager,omitempty"`
	PackageName       *string                 `json:"packageName,omitempty"`
	ParentDepType     *string                 `json:"parentDepType,omitempty"`
	Patch             *map[string]interface{} `json:"patch"`
	Patches           *[]Patch                `json:"patches,omitempty"`
	PublicationTime   *string                 `json:"publicationTime"`
	Semver            *struct {
		Vulnerable         *AnnotatedIssue_Semver_Vulnerable `json:"vulnerable,omitempty"`
		VulnerableByDistro *map[string][]string              `json:"vulnerableByDistro,omitempty"`
		VulnerableHashes   *[]string                         `json:"vulnerableHashes"`
	} `json:"semver,omitempty"`
	Severity    *Severity                          `json:"severity,omitempty"`
	Shrinkwrap  *map[string]interface{}            `json:"shrinkwrap"`
	Title       *string                            `json:"title,omitempty"`
	Type        *AnnotatedIssueType                `json:"type"`
	UpgradePath *[]AnnotatedIssue_UpgradePath_Item `json:"upgradePath,omitempty"`
	Version     *string                            `json:"version,omitempty"`
}

// AnnotatedIssueSemverVulnerable0 defines model for .
type AnnotatedIssueSemverVulnerable0 = string

// AnnotatedIssueSemverVulnerable1 defines model for .
type AnnotatedIssueSemverVulnerable1 = []string

// AnnotatedIssue_Semver_Vulnerable defines model for AnnotatedIssue.Semver.Vulnerable.
type AnnotatedIssue_Semver_Vulnerable struct {
	union json.RawMessage
}

// AnnotatedIssueType defines model for AnnotatedIssue.Type.
type AnnotatedIssueType string

// AnnotatedIssueUpgradePath0 defines model for .
type AnnotatedIssueUpgradePath0 = string

// AnnotatedIssueUpgradePath1 defines model for .
type AnnotatedIssueUpgradePath1 = bool

// AnnotatedIssue_UpgradePath_Item defines model for AnnotatedIssue.upgradePath.Item.
type AnnotatedIssue_UpgradePath_Item struct {
	union json.RawMessage
}

// AnnotatedIssueExtra defines model for AnnotatedIssueExtra.
type AnnotatedIssueExtra struct {
	Filename         *string                                 `json:"__filename"`
	Bundled          *map[string]interface{}                 `json:"bundled"`
	Credit           *[]string                               `json:"credit,omitempty"`
	CvssScore        *float32                                `json:"cvssScore"`
	From             *[]string                               `json:"from,omitempty"`
	Identifiers      *map[string][]string                    `json:"identifiers,omitempty"`
	IsPatchable      *bool                                   `json:"isPatchable,omitempty"`
	IsUpgradable     *bool                                   `json:"isUpgradable,omitempty"`
	LineNumber       *int                                    `json:"lineNumber"`
	Name             *string                                 `json:"name,omitempty"`
	Note             *string                                 `json:"note"`
	OriginalSeverity *Severity                               `json:"originalSeverity,omitempty"`
	ParentDepType    *string                                 `json:"parentDepType,omitempty"`
	Patch            *map[string]interface{}                 `json:"patch"`
	PublicationTime  *string                                 `json:"publicationTime"`
	Severity         *Severity                               `json:"severity,omitempty"`
	Shrinkwrap       *map[string]interface{}                 `json:"shrinkwrap"`
	Title            *string                                 `json:"title,omitempty"`
	Type             *AnnotatedIssueExtraType                `json:"type"`
	UpgradePath      *[]AnnotatedIssueExtra_UpgradePath_Item `json:"upgradePath,omitempty"`
	Version          *string                                 `json:"version,omitempty"`
}

// AnnotatedIssueExtraType defines model for AnnotatedIssueExtra.Type.
type AnnotatedIssueExtraType string

// AnnotatedIssueExtraUpgradePath0 defines model for .
type AnnotatedIssueExtraUpgradePath0 = string

// AnnotatedIssueExtraUpgradePath1 defines model for .
type AnnotatedIssueExtraUpgradePath1 = bool

// AnnotatedIssueExtra_UpgradePath_Item defines model for AnnotatedIssueExtra.upgradePath.Item.
type AnnotatedIssueExtra_UpgradePath_Item struct {
	union json.RawMessage
}

// BaseImageRemediation defines model for BaseImageRemediation.
type BaseImageRemediation struct {
	Advice  *[]BaseImageRemediationAdvice `json:"advice,omitempty"`
	Code    *string                       `json:"code,omitempty"`
	Message *string                       `json:"message"`
}

// BaseImageRemediationAdvice defines model for BaseImageRemediationAdvice.
type BaseImageRemediationAdvice struct {
	Bold    *bool   `json:"bold"`
	Color   *string `json:"color"`
	Message *string `json:"message,omitempty"`
}

// BasicResultData defines model for BasicResultData.
type BasicResultData struct {
	IsPrivate         *bool                  `json:"isPrivate,omitempty"`
	Ok                *bool                  `json:"ok,omitempty"`
	Org               *string                `json:"org,omitempty"`
	PackageManager    *SupportedProjectTypes `json:"packageManager,omitempty"`
	PayloadType       *string                `json:"payloadType"`
	Platform          *string                `json:"platform"`
	SeverityThreshold *string                `json:"severityThreshold"`
	Summary           *string                `json:"summary,omitempty"`
}

// CallPath defines model for CallPath.
type CallPath = []string

// ContainerTarget defines model for ContainerTarget.
type ContainerTarget struct {
	Image *string `json:"image,omitempty"`
}

// DependencyPins defines model for DependencyPins.
type DependencyPins map[string]PinRemediation

// DependencyUpdates defines model for DependencyUpdates.
type DependencyUpdates map[string]UpgradeRemediation

// DepsFilePaths defines model for DepsFilePaths.
type DepsFilePaths map[string][]string

// DockerIssue defines model for DockerIssue.
type DockerIssue struct {
	Below                 *string                 `json:"below,omitempty"`
	Description           *string                 `json:"description,omitempty"`
	DockerBaseImage       *map[string]interface{} `json:"dockerBaseImage"`
	DockerfileInstruction *map[string]interface{} `json:"dockerfileInstruction"`
	FixedIn               *[]string               `json:"fixedIn,omitempty"`
	From                  *[]string               `json:"from"`
	Id                    *string                 `json:"id,omitempty"`
	IsNew                 *bool                   `json:"isNew,omitempty"`
	LegalInstructions     *string                 `json:"legalInstructions"`
	ModuleName            *string                 `json:"moduleName"`
	Name                  *string                 `json:"name"`
	NearestFixedInVersion *string                 `json:"nearestFixedInVersion"`
	PackageManager        *SupportedProjectTypes  `json:"packageManager,omitempty"`
	PackageName           *string                 `json:"packageName,omitempty"`
	Patches               *[]Patch                `json:"patches,omitempty"`
	Semver                *struct {
		Vulnerable         *DockerIssue_Semver_Vulnerable `json:"vulnerable,omitempty"`
		VulnerableByDistro *map[string][]string           `json:"vulnerableByDistro,omitempty"`
		VulnerableHashes   *[]string                      `json:"vulnerableHashes"`
	} `json:"semver,omitempty"`
	Severity *Severity `json:"severity,omitempty"`
	Title    *string   `json:"title,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// DockerIssueSemverVulnerable0 defines model for .
type DockerIssueSemverVulnerable0 = string

// DockerIssueSemverVulnerable1 defines model for .
type DockerIssueSemverVulnerable1 = []string

// DockerIssue_Semver_Vulnerable defines model for DockerIssue.Semver.Vulnerable.
type DockerIssue_Semver_Vulnerable struct {
	union json.RawMessage
}

// DockerIssueExtra defines model for DockerIssueExtra.
type DockerIssueExtra struct {
	DockerBaseImage       *map[string]interface{} `json:"dockerBaseImage"`
	DockerfileInstruction *map[string]interface{} `json:"dockerfileInstruction"`
	NearestFixedInVersion *string                 `json:"nearestFixedInVersion"`
}

// Facts defines model for Facts.
type Facts struct {
	Data *map[string]interface{} `json:"data,omitempty"`
	Type *string                 `json:"type,omitempty"`
}

// FileSignaturesDetails defines model for FileSignaturesDetails.
type FileSignaturesDetails map[string]struct {
	Confidence *float32  `json:"confidence,omitempty"`
	FilePaths  *[]string `json:"filePaths,omitempty"`
}

// Finding defines model for Finding.
type Finding struct {
	Data *map[string]interface{} `json:"data,omitempty"`
	Type *FindingType            `json:"type,omitempty"`
}

// FindingType defines model for FindingType.
type FindingType string

// FixInfo defines model for FixInfo.
type FixInfo struct {
	IsPatchable           *bool          `json:"isPatchable,omitempty"`
	NearestFixedInVersion *string        `json:"nearestFixedInVersion"`
	UpgradePaths          *[]UpgradePath `json:"upgradePaths,omitempty"`
}

// GitTarget defines model for GitTarget.
type GitTarget struct {
	Branch    *string `json:"branch"`
	RemoteUrl *string `json:"remoteUrl"`
}

// GroupedVuln defines model for GroupedVuln.
type GroupedVuln struct {
	FixedIn                *[]string           `json:"fixedIn,omitempty"`
	IsFixable              *bool               `json:"isFixable,omitempty"`
	IsIgnored              *bool               `json:"isIgnored,omitempty"`
	IsNew                  *bool               `json:"isNew,omitempty"`
	LegalInstructionsArray *[]LegalInstruction `json:"legalInstructionsArray,omitempty"`
	List                   *[]AnnotatedIssue   `json:"list,omitempty"`
	Metadata               *VulnMetaData       `json:"metadata,omitempty"`
	Name                   *string             `json:"name,omitempty"`
	Note                   *string             `json:"note"`
	OriginalSeverity       *Severity           `json:"originalSeverity,omitempty"`
	Severity               *Severity           `json:"severity,omitempty"`
	Title                  *string             `json:"title,omitempty"`
	Version                *string             `json:"version,omitempty"`
}

// IacProjectTypes defines model for IacProjectTypes.
type IacProjectTypes string

// Identity defines model for Identity.
type Identity struct {
	Args       *map[string]string `json:"args,omitempty"`
	TargetFile *string            `json:"targetFile"`
	Type       *string            `json:"type,omitempty"`
}

// Ignore defines model for Ignore.
type Ignore struct {
	Meta *struct {
		Days   *int    `json:"days"`
		Reason *string `json:"reason"`
	} `json:"meta,omitempty"`
	Paths *[][]string `json:"paths,omitempty"`
}

// IgnoreSettings defines model for IgnoreSettings.
type IgnoreSettings struct {
	AdminOnly                  *bool `json:"adminOnly,omitempty"`
	DisregardFilesystemIgnores *bool `json:"disregardFilesystemIgnores,omitempty"`
	ReasonRequired             *bool `json:"reasonRequired,omitempty"`
}

// Ignores defines model for Ignores.
type Ignores map[string]Ignore

// Issue defines model for Issue.
type Issue struct {
	FixInfo    *FixInfo `json:"fixInfo,omitempty"`
	IssueId    *string  `json:"issueId,omitempty"`
	PkgName    *string  `json:"pkgName,omitempty"`
	PkgVersion *string  `json:"pkgVersion"`
}

// IssueData defines model for IssueData.
type IssueData struct {
	Below             *string                `json:"below,omitempty"`
	Description       *string                `json:"description,omitempty"`
	FixedIn           *[]string              `json:"fixedIn,omitempty"`
	From              *[]string              `json:"from"`
	Id                *string                `json:"id,omitempty"`
	IsNew             *bool                  `json:"isNew,omitempty"`
	LegalInstructions *string                `json:"legalInstructions"`
	ModuleName        *string                `json:"moduleName"`
	Name              *string                `json:"name"`
	PackageManager    *SupportedProjectTypes `json:"packageManager,omitempty"`
	PackageName       *string                `json:"packageName,omitempty"`
	Patches           *[]Patch               `json:"patches,omitempty"`
	Semver            *struct {
		Vulnerable         *IssueData_Semver_Vulnerable `json:"vulnerable,omitempty"`
		VulnerableByDistro *map[string][]string         `json:"vulnerableByDistro,omitempty"`
		VulnerableHashes   *[]string                    `json:"vulnerableHashes"`
	} `json:"semver,omitempty"`
	Severity *Severity `json:"severity,omitempty"`
	Title    *string   `json:"title,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// IssueDataSemverVulnerable0 defines model for .
type IssueDataSemverVulnerable0 = string

// IssueDataSemverVulnerable1 defines model for .
type IssueDataSemverVulnerable1 = []string

// IssueData_Semver_Vulnerable defines model for IssueData.Semver.Vulnerable.
type IssueData_Semver_Vulnerable struct {
	union json.RawMessage
}

// IssueDataUnmanaged defines model for IssueDataUnmanaged.
type IssueDataUnmanaged = IssueData

// LegacyVulnApiResult defines model for LegacyVulnApiResult.
type LegacyVulnApiResult struct {
	DependencyCount *int `json:"dependencyCount,omitempty"`
	Docker          *struct {
		BaseImage            *map[string]interface{} `json:"baseImage"`
		BaseImageRemediation *BaseImageRemediation   `json:"baseImageRemediation,omitempty"`
		BinariesVulns        *map[string]interface{} `json:"binariesVulns,omitempty"`
	} `json:"docker,omitempty"`
	FilesystemPolicy  *bool                               `json:"filesystemPolicy"`
	IgnoreSettings    *LegacyVulnApiResult_IgnoreSettings `json:"ignoreSettings,omitempty"`
	IsPrivate         *bool                               `json:"isPrivate,omitempty"`
	LicensesPolicy    *LegacyVulnApiResult_LicensesPolicy `json:"licensesPolicy,omitempty"`
	Ok                *bool                               `json:"ok,omitempty"`
	Org               *string                             `json:"org,omitempty"`
	PackageManager    *SupportedProjectTypes              `json:"packageManager,omitempty"`
	PayloadType       *string                             `json:"payloadType"`
	Platform          *string                             `json:"platform"`
	Policy            *string                             `json:"policy,omitempty"`
	ProjectId         *string                             `json:"projectId"`
	Remediation       *RemediationChanges                 `json:"remediation,omitempty"`
	SeverityThreshold *string                             `json:"severityThreshold"`
	Summary           *string                             `json:"summary,omitempty"`
	UniqueCount       *map[string]interface{}             `json:"uniqueCount,omitempty"`
	Vulnerabilities   *[]AnnotatedIssue                   `json:"vulnerabilities,omitempty"`
}

// LegacyVulnApiResultIgnoreSettings1 defines model for .
type LegacyVulnApiResultIgnoreSettings1 = interface{}

// LegacyVulnApiResult_IgnoreSettings defines model for LegacyVulnApiResult.IgnoreSettings.
type LegacyVulnApiResult_IgnoreSettings struct {
	union json.RawMessage
}

// LegacyVulnApiResultLicensesPolicy0 defines model for .
type LegacyVulnApiResultLicensesPolicy0 = map[string]interface{}

// LegacyVulnApiResultLicensesPolicy1 defines model for .
type LegacyVulnApiResultLicensesPolicy1 = interface{}

// LegacyVulnApiResult_LicensesPolicy defines model for LegacyVulnApiResult.LicensesPolicy.
type LegacyVulnApiResult_LicensesPolicy struct {
	union json.RawMessage
}

// LegacyVulnApiResultExtra defines model for LegacyVulnApiResultExtra.
type LegacyVulnApiResultExtra struct {
	DependencyCount *int `json:"dependencyCount,omitempty"`
	Docker          *struct {
		BaseImage            *map[string]interface{} `json:"baseImage"`
		BaseImageRemediation *BaseImageRemediation   `json:"baseImageRemediation,omitempty"`
		BinariesVulns        *map[string]interface{} `json:"binariesVulns,omitempty"`
	} `json:"docker,omitempty"`
	FilesystemPolicy *bool                                    `json:"filesystemPolicy"`
	IgnoreSettings   *LegacyVulnApiResultExtra_IgnoreSettings `json:"ignoreSettings,omitempty"`
	LicensesPolicy   *LegacyVulnApiResultExtra_LicensesPolicy `json:"licensesPolicy,omitempty"`
	Policy           *string                                  `json:"policy,omitempty"`
	ProjectId        *string                                  `json:"projectId"`
	Remediation      *RemediationChanges                      `json:"remediation,omitempty"`
	UniqueCount      *map[string]interface{}                  `json:"uniqueCount,omitempty"`
	Vulnerabilities  *[]AnnotatedIssue                        `json:"vulnerabilities,omitempty"`
}

// LegacyVulnApiResultExtraIgnoreSettings1 defines model for .
type LegacyVulnApiResultExtraIgnoreSettings1 = interface{}

// LegacyVulnApiResultExtra_IgnoreSettings defines model for LegacyVulnApiResultExtra.IgnoreSettings.
type LegacyVulnApiResultExtra_IgnoreSettings struct {
	union json.RawMessage
}

// LegacyVulnApiResultExtraLicensesPolicy0 defines model for .
type LegacyVulnApiResultExtraLicensesPolicy0 = map[string]interface{}

// LegacyVulnApiResultExtraLicensesPolicy1 defines model for .
type LegacyVulnApiResultExtraLicensesPolicy1 = interface{}

// LegacyVulnApiResultExtra_LicensesPolicy defines model for LegacyVulnApiResultExtra.LicensesPolicy.
type LegacyVulnApiResultExtra_LicensesPolicy struct {
	union json.RawMessage
}

// LegalInstruction defines model for LegalInstruction.
type LegalInstruction struct {
	LegalContent *string `json:"legalContent,omitempty"`
	LicenseName  *string `json:"licenseName,omitempty"`
}

// NamedTarget defines model for NamedTarget.
type NamedTarget = GitTarget

// Patch defines model for Patch.
type Patch struct {
	Id               *string   `json:"id,omitempty"`
	ModificationTime *string   `json:"modificationTime,omitempty"`
	Urls             *[]string `json:"urls,omitempty"`
	Version          *string   `json:"version,omitempty"`
}

// PatchObject defines model for PatchObject.
type PatchObject map[string]struct {
	Patched *string `json:"patched,omitempty"`
}

// PatchRemediation defines model for PatchRemediation.
type PatchRemediation struct {
	Paths *[]PatchObject `json:"paths,omitempty"`
}

// PinRemediation defines model for PinRemediation.
type PinRemediation struct {
	IsTransitive *bool     `json:"isTransitive,omitempty"`
	UpgradeTo    *string   `json:"upgradeTo,omitempty"`
	Vulns        *[]string `json:"vulns,omitempty"`
}

// PinRemediationExtra defines model for PinRemediationExtra.
type PinRemediationExtra struct {
	IsTransitive *bool `json:"isTransitive,omitempty"`
}

// Pkg defines model for Pkg.
type Pkg struct {
	Name    *string `json:"name,omitempty"`
	Version *string `json:"version"`
}

// RemediationChanges defines model for RemediationChanges.
type RemediationChanges struct {
	Ignore     *map[string]interface{}      `json:"ignore,omitempty"`
	Patch      *map[string]PatchRemediation `json:"patch,omitempty"`
	Pin        *DependencyPins              `json:"pin,omitempty"`
	Unresolved *[]IssueData                 `json:"unresolved,omitempty"`
	Upgrade    *DependencyUpdates           `json:"upgrade,omitempty"`
}

// ScanResult defines model for ScanResult.
type ScanResult struct {
	Analytics       *[]Analytics       `json:"analytics"`
	Facts           *[]Facts           `json:"facts,omitempty"`
	Findings        *[]Finding         `json:"findings"`
	Identity        *Identity          `json:"identity,omitempty"`
	Name            *string            `json:"name"`
	Policy          *string            `json:"policy"`
	Target          *ScanResult_Target `json:"target,omitempty"`
	TargetReference *string            `json:"targetReference"`
}

// ScanResult_Target defines model for ScanResult.Target.
type ScanResult_Target struct {
	union json.RawMessage
}

// Severity defines model for Severity.
type Severity string

// SupportedPackageManagers defines model for SupportedPackageManagers.
type SupportedPackageManagers string

// SupportedProjectTypes defines model for SupportedProjectTypes.
type SupportedProjectTypes struct {
	union json.RawMessage
}

// TestDepGraphMeta defines model for TestDepGraphMeta.
type TestDepGraphMeta struct {
	IgnoreSettings    *IgnoreSettings `json:"ignoreSettings,omitempty"`
	IsLicensesEnabled *bool           `json:"isLicensesEnabled,omitempty"`
	IsPublic          *bool           `json:"isPublic,omitempty"`
	LicensesPolicy    *struct {
		Severities *map[string]string `json:"severities,omitempty"`
	} `json:"licensesPolicy,omitempty"`
	Org       *string `json:"org,omitempty"`
	Policy    *string `json:"policy,omitempty"`
	ProjectId *string `json:"projectId"`
}

// TestDepGraphResponse defines model for TestDepGraphResponse.
type TestDepGraphResponse struct {
	Meta   *TestDepGraphMeta   `json:"meta,omitempty"`
	Result *TestDepGraphResult `json:"result,omitempty"`
}

// TestDepGraphResult defines model for TestDepGraphResult.
type TestDepGraphResult struct {
	AffectedPkgs *AffectedPackages `json:"affectedPkgs,omitempty"`
	Docker       *struct {
		BaseImage     *map[string]interface{} `json:"baseImage"`
		BinariesVulns *TestDepGraphResult     `json:"binariesVulns,omitempty"`
	} `json:"docker,omitempty"`
	IssuesData  *map[string]IssueData `json:"issuesData,omitempty"`
	Remediation *RemediationChanges   `json:"remediation,omitempty"`
}

// TestDependenciesResponse defines model for TestDependenciesResponse.
type TestDependenciesResponse struct {
	Meta   *TestDepGraphMeta       `json:"meta,omitempty"`
	Result *TestDependenciesResult `json:"result,omitempty"`
}

// TestDependenciesResult defines model for TestDependenciesResult.
type TestDependenciesResult struct {
	DepGraphData    *externalRef0.DepGraphData            `json:"depGraphData,omitempty"`
	DependencyCount *int                                  `json:"dependencyCount,omitempty"`
	DepsFilePaths   *TestDependenciesResult_DepsFilePaths `json:"depsFilePaths,omitempty"`
	Docker          *struct {
		BaseImage            *string               `json:"baseImage,omitempty"`
		BaseImageRemediation *BaseImageRemediation `json:"baseImageRemediation,omitempty"`
		BinariesVulns        *TestDepGraphResult   `json:"binariesVulns,omitempty"`
	} `json:"docker,omitempty"`
	FileSignaturesDetails *FileSignaturesDetails         `json:"fileSignaturesDetails,omitempty"`
	Issues                *[]Issue                       `json:"issues,omitempty"`
	IssuesData            *map[string]IssueDataUnmanaged `json:"issuesData,omitempty"`
	PackageManager        *SupportedProjectTypes         `json:"packageManager,omitempty"`
	Path                  *string                        `json:"path,omitempty"`
	Remediation           *RemediationChanges            `json:"remediation,omitempty"`
	Vulnerabilities       *[]IssueData                   `json:"vulnerabilities,omitempty"`
}

// TestDependenciesResultDepsFilePaths1 defines model for .
type TestDependenciesResultDepsFilePaths1 = interface{}

// TestDependenciesResult_DepsFilePaths defines model for TestDependenciesResult.DepsFilePaths.
type TestDependenciesResult_DepsFilePaths struct {
	union json.RawMessage
}

// TestResult defines model for TestResult.
type TestResult struct {
	DependencyCount   *int    `json:"dependencyCount,omitempty"`
	DisplayTargetFile *string `json:"displayTargetFile"`
	Docker            *struct {
		BaseImage            *map[string]interface{} `json:"baseImage"`
		BaseImageRemediation *BaseImageRemediation   `json:"baseImageRemediation,omitempty"`
		BinariesVulns        *map[string]interface{} `json:"binariesVulns,omitempty"`
	} `json:"docker,omitempty"`
	FilesystemPolicy   *bool                      `json:"filesystemPolicy"`
	FoundProjectCount  *int                       `json:"foundProjectCount"`
	HasUnknownVersions *bool                      `json:"hasUnknownVersions,omitempty"`
	IgnoreSettings     *TestResult_IgnoreSettings `json:"ignoreSettings,omitempty"`
	IsPrivate          *bool                      `json:"isPrivate,omitempty"`
	LicensesPolicy     *TestResult_LicensesPolicy `json:"licensesPolicy,omitempty"`
	Ok                 *bool                      `json:"ok,omitempty"`
	Org                *string                    `json:"org,omitempty"`
	PackageManager     *SupportedProjectTypes     `json:"packageManager,omitempty"`
	Path               *string                    `json:"path"`
	PayloadType        *string                    `json:"payloadType"`
	Platform           *string                    `json:"platform"`
	Policy             *string                    `json:"policy,omitempty"`
	ProjectId          *string                    `json:"projectId"`
	ProjectName        *string                    `json:"projectName"`
	Remediation        *RemediationChanges        `json:"remediation,omitempty"`
	ScanResult         *ScanResult                `json:"scanResult,omitempty"`
	SeverityThreshold  *string                    `json:"severityThreshold"`
	Summary            *string                    `json:"summary,omitempty"`
	TargetFile         *string                    `json:"targetFile"`
	TargetFilePath     *string                    `json:"targetFilePath"`
	UniqueCount        *map[string]interface{}    `json:"uniqueCount,omitempty"`
	Vulnerabilities    *[]AnnotatedIssue          `json:"vulnerabilities,omitempty"`
}

// TestResultIgnoreSettings1 defines model for .
type TestResultIgnoreSettings1 = interface{}

// TestResult_IgnoreSettings defines model for TestResult.IgnoreSettings.
type TestResult_IgnoreSettings struct {
	union json.RawMessage
}

// TestResultLicensesPolicy0 defines model for .
type TestResultLicensesPolicy0 = map[string]interface{}

// TestResultLicensesPolicy1 defines model for .
type TestResultLicensesPolicy1 = interface{}

// TestResult_LicensesPolicy defines model for TestResult.LicensesPolicy.
type TestResult_LicensesPolicy struct {
	union json.RawMessage
}

// TestResultExtra defines model for TestResultExtra.
type TestResultExtra struct {
	DisplayTargetFile  *string     `json:"displayTargetFile"`
	FoundProjectCount  *int        `json:"foundProjectCount"`
	HasUnknownVersions *bool       `json:"hasUnknownVersions,omitempty"`
	Path               *string     `json:"path"`
	ProjectName        *string     `json:"projectName"`
	ScanResult         *ScanResult `json:"scanResult,omitempty"`
	TargetFile         *string     `json:"targetFile"`
	TargetFilePath     *string     `json:"targetFilePath"`
}

// Upgrade defines model for Upgrade.
type Upgrade struct {
	UpgradeTo *string `json:"upgradeTo,omitempty"`
}

// UpgradePath defines model for UpgradePath.
type UpgradePath struct {
	Path *[]UpgradePathItem `json:"path,omitempty"`
}

// UpgradePathItem defines model for UpgradePathItem.
type UpgradePathItem struct {
	IsDropped  *bool   `json:"isDropped"`
	Name       *string `json:"name,omitempty"`
	NewVersion *string `json:"newVersion"`
	Version    *string `json:"version,omitempty"`
}

// UpgradeRemediation defines model for UpgradeRemediation.
type UpgradeRemediation struct {
	UpgradeTo *string   `json:"upgradeTo,omitempty"`
	Upgrades  *[]string `json:"upgrades,omitempty"`
	Vulns     *[]string `json:"vulns,omitempty"`
}

// UpgradeRemediationExtra defines model for UpgradeRemediationExtra.
type UpgradeRemediationExtra struct {
	Upgrades *[]string `json:"upgrades,omitempty"`
}

// UpgradeVulns defines model for UpgradeVulns.
type UpgradeVulns struct {
	UpgradeTo *string   `json:"upgradeTo,omitempty"`
	Vulns     *[]string `json:"vulns,omitempty"`
}

// UpgradeVulnsExtra defines model for UpgradeVulnsExtra.
type UpgradeVulnsExtra struct {
	Vulns *[]string `json:"vulns,omitempty"`
}

// VulnMetaData defines model for VulnMetaData.
type VulnMetaData struct {
	Description    *string                   `json:"description,omitempty"`
	Id             *string                   `json:"id,omitempty"`
	Info           *string                   `json:"info,omitempty"`
	IsNew          *bool                     `json:"isNew,omitempty"`
	Name           *string                   `json:"name,omitempty"`
	PackageManager *SupportedPackageManagers `json:"packageManager,omitempty"`
	Severity       *Severity                 `json:"severity,omitempty"`
	SeverityValue  *float32                  `json:"severityValue,omitempty"`
	Title          *string                   `json:"title,omitempty"`
	Type           *VulnMetaDataType         `json:"type,omitempty"`
	Version        *string                   `json:"version,omitempty"`
}

// VulnMetaDataType defines model for VulnMetaData.Type.
type VulnMetaDataType string

// AsAnnotatedIssueSemverVulnerable0 returns the union data inside the AnnotatedIssue_Semver_Vulnerable as a AnnotatedIssueSemverVulnerable0
func (t AnnotatedIssue_Semver_Vulnerable) AsAnnotatedIssueSemverVulnerable0() (AnnotatedIssueSemverVulnerable0, error) {
	var body AnnotatedIssueSemverVulnerable0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnnotatedIssueSemverVulnerable0 overwrites any union data inside the AnnotatedIssue_Semver_Vulnerable as the provided AnnotatedIssueSemverVulnerable0
func (t *AnnotatedIssue_Semver_Vulnerable) FromAnnotatedIssueSemverVulnerable0(v AnnotatedIssueSemverVulnerable0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnnotatedIssueSemverVulnerable0 performs a merge with any union data inside the AnnotatedIssue_Semver_Vulnerable, using the provided AnnotatedIssueSemverVulnerable0
func (t *AnnotatedIssue_Semver_Vulnerable) MergeAnnotatedIssueSemverVulnerable0(v AnnotatedIssueSemverVulnerable0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnnotatedIssueSemverVulnerable1 returns the union data inside the AnnotatedIssue_Semver_Vulnerable as a AnnotatedIssueSemverVulnerable1
func (t AnnotatedIssue_Semver_Vulnerable) AsAnnotatedIssueSemverVulnerable1() (AnnotatedIssueSemverVulnerable1, error) {
	var body AnnotatedIssueSemverVulnerable1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnnotatedIssueSemverVulnerable1 overwrites any union data inside the AnnotatedIssue_Semver_Vulnerable as the provided AnnotatedIssueSemverVulnerable1
func (t *AnnotatedIssue_Semver_Vulnerable) FromAnnotatedIssueSemverVulnerable1(v AnnotatedIssueSemverVulnerable1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnnotatedIssueSemverVulnerable1 performs a merge with any union data inside the AnnotatedIssue_Semver_Vulnerable, using the provided AnnotatedIssueSemverVulnerable1
func (t *AnnotatedIssue_Semver_Vulnerable) MergeAnnotatedIssueSemverVulnerable1(v AnnotatedIssueSemverVulnerable1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnnotatedIssue_Semver_Vulnerable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnnotatedIssue_Semver_Vulnerable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAnnotatedIssueUpgradePath0 returns the union data inside the AnnotatedIssue_UpgradePath_Item as a AnnotatedIssueUpgradePath0
func (t AnnotatedIssue_UpgradePath_Item) AsAnnotatedIssueUpgradePath0() (AnnotatedIssueUpgradePath0, error) {
	var body AnnotatedIssueUpgradePath0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnnotatedIssueUpgradePath0 overwrites any union data inside the AnnotatedIssue_UpgradePath_Item as the provided AnnotatedIssueUpgradePath0
func (t *AnnotatedIssue_UpgradePath_Item) FromAnnotatedIssueUpgradePath0(v AnnotatedIssueUpgradePath0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnnotatedIssueUpgradePath0 performs a merge with any union data inside the AnnotatedIssue_UpgradePath_Item, using the provided AnnotatedIssueUpgradePath0
func (t *AnnotatedIssue_UpgradePath_Item) MergeAnnotatedIssueUpgradePath0(v AnnotatedIssueUpgradePath0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnnotatedIssueUpgradePath1 returns the union data inside the AnnotatedIssue_UpgradePath_Item as a AnnotatedIssueUpgradePath1
func (t AnnotatedIssue_UpgradePath_Item) AsAnnotatedIssueUpgradePath1() (AnnotatedIssueUpgradePath1, error) {
	var body AnnotatedIssueUpgradePath1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnnotatedIssueUpgradePath1 overwrites any union data inside the AnnotatedIssue_UpgradePath_Item as the provided AnnotatedIssueUpgradePath1
func (t *AnnotatedIssue_UpgradePath_Item) FromAnnotatedIssueUpgradePath1(v AnnotatedIssueUpgradePath1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnnotatedIssueUpgradePath1 performs a merge with any union data inside the AnnotatedIssue_UpgradePath_Item, using the provided AnnotatedIssueUpgradePath1
func (t *AnnotatedIssue_UpgradePath_Item) MergeAnnotatedIssueUpgradePath1(v AnnotatedIssueUpgradePath1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnnotatedIssue_UpgradePath_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnnotatedIssue_UpgradePath_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAnnotatedIssueExtraUpgradePath0 returns the union data inside the AnnotatedIssueExtra_UpgradePath_Item as a AnnotatedIssueExtraUpgradePath0
func (t AnnotatedIssueExtra_UpgradePath_Item) AsAnnotatedIssueExtraUpgradePath0() (AnnotatedIssueExtraUpgradePath0, error) {
	var body AnnotatedIssueExtraUpgradePath0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnnotatedIssueExtraUpgradePath0 overwrites any union data inside the AnnotatedIssueExtra_UpgradePath_Item as the provided AnnotatedIssueExtraUpgradePath0
func (t *AnnotatedIssueExtra_UpgradePath_Item) FromAnnotatedIssueExtraUpgradePath0(v AnnotatedIssueExtraUpgradePath0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnnotatedIssueExtraUpgradePath0 performs a merge with any union data inside the AnnotatedIssueExtra_UpgradePath_Item, using the provided AnnotatedIssueExtraUpgradePath0
func (t *AnnotatedIssueExtra_UpgradePath_Item) MergeAnnotatedIssueExtraUpgradePath0(v AnnotatedIssueExtraUpgradePath0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnnotatedIssueExtraUpgradePath1 returns the union data inside the AnnotatedIssueExtra_UpgradePath_Item as a AnnotatedIssueExtraUpgradePath1
func (t AnnotatedIssueExtra_UpgradePath_Item) AsAnnotatedIssueExtraUpgradePath1() (AnnotatedIssueExtraUpgradePath1, error) {
	var body AnnotatedIssueExtraUpgradePath1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnnotatedIssueExtraUpgradePath1 overwrites any union data inside the AnnotatedIssueExtra_UpgradePath_Item as the provided AnnotatedIssueExtraUpgradePath1
func (t *AnnotatedIssueExtra_UpgradePath_Item) FromAnnotatedIssueExtraUpgradePath1(v AnnotatedIssueExtraUpgradePath1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnnotatedIssueExtraUpgradePath1 performs a merge with any union data inside the AnnotatedIssueExtra_UpgradePath_Item, using the provided AnnotatedIssueExtraUpgradePath1
func (t *AnnotatedIssueExtra_UpgradePath_Item) MergeAnnotatedIssueExtraUpgradePath1(v AnnotatedIssueExtraUpgradePath1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnnotatedIssueExtra_UpgradePath_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnnotatedIssueExtra_UpgradePath_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDockerIssueSemverVulnerable0 returns the union data inside the DockerIssue_Semver_Vulnerable as a DockerIssueSemverVulnerable0
func (t DockerIssue_Semver_Vulnerable) AsDockerIssueSemverVulnerable0() (DockerIssueSemverVulnerable0, error) {
	var body DockerIssueSemverVulnerable0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerIssueSemverVulnerable0 overwrites any union data inside the DockerIssue_Semver_Vulnerable as the provided DockerIssueSemverVulnerable0
func (t *DockerIssue_Semver_Vulnerable) FromDockerIssueSemverVulnerable0(v DockerIssueSemverVulnerable0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerIssueSemverVulnerable0 performs a merge with any union data inside the DockerIssue_Semver_Vulnerable, using the provided DockerIssueSemverVulnerable0
func (t *DockerIssue_Semver_Vulnerable) MergeDockerIssueSemverVulnerable0(v DockerIssueSemverVulnerable0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerIssueSemverVulnerable1 returns the union data inside the DockerIssue_Semver_Vulnerable as a DockerIssueSemverVulnerable1
func (t DockerIssue_Semver_Vulnerable) AsDockerIssueSemverVulnerable1() (DockerIssueSemverVulnerable1, error) {
	var body DockerIssueSemverVulnerable1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerIssueSemverVulnerable1 overwrites any union data inside the DockerIssue_Semver_Vulnerable as the provided DockerIssueSemverVulnerable1
func (t *DockerIssue_Semver_Vulnerable) FromDockerIssueSemverVulnerable1(v DockerIssueSemverVulnerable1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerIssueSemverVulnerable1 performs a merge with any union data inside the DockerIssue_Semver_Vulnerable, using the provided DockerIssueSemverVulnerable1
func (t *DockerIssue_Semver_Vulnerable) MergeDockerIssueSemverVulnerable1(v DockerIssueSemverVulnerable1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DockerIssue_Semver_Vulnerable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DockerIssue_Semver_Vulnerable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueDataSemverVulnerable0 returns the union data inside the IssueData_Semver_Vulnerable as a IssueDataSemverVulnerable0
func (t IssueData_Semver_Vulnerable) AsIssueDataSemverVulnerable0() (IssueDataSemverVulnerable0, error) {
	var body IssueDataSemverVulnerable0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueDataSemverVulnerable0 overwrites any union data inside the IssueData_Semver_Vulnerable as the provided IssueDataSemverVulnerable0
func (t *IssueData_Semver_Vulnerable) FromIssueDataSemverVulnerable0(v IssueDataSemverVulnerable0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueDataSemverVulnerable0 performs a merge with any union data inside the IssueData_Semver_Vulnerable, using the provided IssueDataSemverVulnerable0
func (t *IssueData_Semver_Vulnerable) MergeIssueDataSemverVulnerable0(v IssueDataSemverVulnerable0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueDataSemverVulnerable1 returns the union data inside the IssueData_Semver_Vulnerable as a IssueDataSemverVulnerable1
func (t IssueData_Semver_Vulnerable) AsIssueDataSemverVulnerable1() (IssueDataSemverVulnerable1, error) {
	var body IssueDataSemverVulnerable1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueDataSemverVulnerable1 overwrites any union data inside the IssueData_Semver_Vulnerable as the provided IssueDataSemverVulnerable1
func (t *IssueData_Semver_Vulnerable) FromIssueDataSemverVulnerable1(v IssueDataSemverVulnerable1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueDataSemverVulnerable1 performs a merge with any union data inside the IssueData_Semver_Vulnerable, using the provided IssueDataSemverVulnerable1
func (t *IssueData_Semver_Vulnerable) MergeIssueDataSemverVulnerable1(v IssueDataSemverVulnerable1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueData_Semver_Vulnerable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueData_Semver_Vulnerable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIgnoreSettings returns the union data inside the LegacyVulnApiResult_IgnoreSettings as a IgnoreSettings
func (t LegacyVulnApiResult_IgnoreSettings) AsIgnoreSettings() (IgnoreSettings, error) {
	var body IgnoreSettings
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnoreSettings overwrites any union data inside the LegacyVulnApiResult_IgnoreSettings as the provided IgnoreSettings
func (t *LegacyVulnApiResult_IgnoreSettings) FromIgnoreSettings(v IgnoreSettings) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnoreSettings performs a merge with any union data inside the LegacyVulnApiResult_IgnoreSettings, using the provided IgnoreSettings
func (t *LegacyVulnApiResult_IgnoreSettings) MergeIgnoreSettings(v IgnoreSettings) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLegacyVulnApiResultIgnoreSettings1 returns the union data inside the LegacyVulnApiResult_IgnoreSettings as a LegacyVulnApiResultIgnoreSettings1
func (t LegacyVulnApiResult_IgnoreSettings) AsLegacyVulnApiResultIgnoreSettings1() (LegacyVulnApiResultIgnoreSettings1, error) {
	var body LegacyVulnApiResultIgnoreSettings1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyVulnApiResultIgnoreSettings1 overwrites any union data inside the LegacyVulnApiResult_IgnoreSettings as the provided LegacyVulnApiResultIgnoreSettings1
func (t *LegacyVulnApiResult_IgnoreSettings) FromLegacyVulnApiResultIgnoreSettings1(v LegacyVulnApiResultIgnoreSettings1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyVulnApiResultIgnoreSettings1 performs a merge with any union data inside the LegacyVulnApiResult_IgnoreSettings, using the provided LegacyVulnApiResultIgnoreSettings1
func (t *LegacyVulnApiResult_IgnoreSettings) MergeLegacyVulnApiResultIgnoreSettings1(v LegacyVulnApiResultIgnoreSettings1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LegacyVulnApiResult_IgnoreSettings) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegacyVulnApiResult_IgnoreSettings) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLegacyVulnApiResultLicensesPolicy0 returns the union data inside the LegacyVulnApiResult_LicensesPolicy as a LegacyVulnApiResultLicensesPolicy0
func (t LegacyVulnApiResult_LicensesPolicy) AsLegacyVulnApiResultLicensesPolicy0() (LegacyVulnApiResultLicensesPolicy0, error) {
	var body LegacyVulnApiResultLicensesPolicy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyVulnApiResultLicensesPolicy0 overwrites any union data inside the LegacyVulnApiResult_LicensesPolicy as the provided LegacyVulnApiResultLicensesPolicy0
func (t *LegacyVulnApiResult_LicensesPolicy) FromLegacyVulnApiResultLicensesPolicy0(v LegacyVulnApiResultLicensesPolicy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyVulnApiResultLicensesPolicy0 performs a merge with any union data inside the LegacyVulnApiResult_LicensesPolicy, using the provided LegacyVulnApiResultLicensesPolicy0
func (t *LegacyVulnApiResult_LicensesPolicy) MergeLegacyVulnApiResultLicensesPolicy0(v LegacyVulnApiResultLicensesPolicy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLegacyVulnApiResultLicensesPolicy1 returns the union data inside the LegacyVulnApiResult_LicensesPolicy as a LegacyVulnApiResultLicensesPolicy1
func (t LegacyVulnApiResult_LicensesPolicy) AsLegacyVulnApiResultLicensesPolicy1() (LegacyVulnApiResultLicensesPolicy1, error) {
	var body LegacyVulnApiResultLicensesPolicy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyVulnApiResultLicensesPolicy1 overwrites any union data inside the LegacyVulnApiResult_LicensesPolicy as the provided LegacyVulnApiResultLicensesPolicy1
func (t *LegacyVulnApiResult_LicensesPolicy) FromLegacyVulnApiResultLicensesPolicy1(v LegacyVulnApiResultLicensesPolicy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyVulnApiResultLicensesPolicy1 performs a merge with any union data inside the LegacyVulnApiResult_LicensesPolicy, using the provided LegacyVulnApiResultLicensesPolicy1
func (t *LegacyVulnApiResult_LicensesPolicy) MergeLegacyVulnApiResultLicensesPolicy1(v LegacyVulnApiResultLicensesPolicy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LegacyVulnApiResult_LicensesPolicy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegacyVulnApiResult_LicensesPolicy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIgnoreSettings returns the union data inside the LegacyVulnApiResultExtra_IgnoreSettings as a IgnoreSettings
func (t LegacyVulnApiResultExtra_IgnoreSettings) AsIgnoreSettings() (IgnoreSettings, error) {
	var body IgnoreSettings
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnoreSettings overwrites any union data inside the LegacyVulnApiResultExtra_IgnoreSettings as the provided IgnoreSettings
func (t *LegacyVulnApiResultExtra_IgnoreSettings) FromIgnoreSettings(v IgnoreSettings) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnoreSettings performs a merge with any union data inside the LegacyVulnApiResultExtra_IgnoreSettings, using the provided IgnoreSettings
func (t *LegacyVulnApiResultExtra_IgnoreSettings) MergeIgnoreSettings(v IgnoreSettings) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLegacyVulnApiResultExtraIgnoreSettings1 returns the union data inside the LegacyVulnApiResultExtra_IgnoreSettings as a LegacyVulnApiResultExtraIgnoreSettings1
func (t LegacyVulnApiResultExtra_IgnoreSettings) AsLegacyVulnApiResultExtraIgnoreSettings1() (LegacyVulnApiResultExtraIgnoreSettings1, error) {
	var body LegacyVulnApiResultExtraIgnoreSettings1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyVulnApiResultExtraIgnoreSettings1 overwrites any union data inside the LegacyVulnApiResultExtra_IgnoreSettings as the provided LegacyVulnApiResultExtraIgnoreSettings1
func (t *LegacyVulnApiResultExtra_IgnoreSettings) FromLegacyVulnApiResultExtraIgnoreSettings1(v LegacyVulnApiResultExtraIgnoreSettings1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyVulnApiResultExtraIgnoreSettings1 performs a merge with any union data inside the LegacyVulnApiResultExtra_IgnoreSettings, using the provided LegacyVulnApiResultExtraIgnoreSettings1
func (t *LegacyVulnApiResultExtra_IgnoreSettings) MergeLegacyVulnApiResultExtraIgnoreSettings1(v LegacyVulnApiResultExtraIgnoreSettings1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LegacyVulnApiResultExtra_IgnoreSettings) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegacyVulnApiResultExtra_IgnoreSettings) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLegacyVulnApiResultExtraLicensesPolicy0 returns the union data inside the LegacyVulnApiResultExtra_LicensesPolicy as a LegacyVulnApiResultExtraLicensesPolicy0
func (t LegacyVulnApiResultExtra_LicensesPolicy) AsLegacyVulnApiResultExtraLicensesPolicy0() (LegacyVulnApiResultExtraLicensesPolicy0, error) {
	var body LegacyVulnApiResultExtraLicensesPolicy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyVulnApiResultExtraLicensesPolicy0 overwrites any union data inside the LegacyVulnApiResultExtra_LicensesPolicy as the provided LegacyVulnApiResultExtraLicensesPolicy0
func (t *LegacyVulnApiResultExtra_LicensesPolicy) FromLegacyVulnApiResultExtraLicensesPolicy0(v LegacyVulnApiResultExtraLicensesPolicy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyVulnApiResultExtraLicensesPolicy0 performs a merge with any union data inside the LegacyVulnApiResultExtra_LicensesPolicy, using the provided LegacyVulnApiResultExtraLicensesPolicy0
func (t *LegacyVulnApiResultExtra_LicensesPolicy) MergeLegacyVulnApiResultExtraLicensesPolicy0(v LegacyVulnApiResultExtraLicensesPolicy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLegacyVulnApiResultExtraLicensesPolicy1 returns the union data inside the LegacyVulnApiResultExtra_LicensesPolicy as a LegacyVulnApiResultExtraLicensesPolicy1
func (t LegacyVulnApiResultExtra_LicensesPolicy) AsLegacyVulnApiResultExtraLicensesPolicy1() (LegacyVulnApiResultExtraLicensesPolicy1, error) {
	var body LegacyVulnApiResultExtraLicensesPolicy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyVulnApiResultExtraLicensesPolicy1 overwrites any union data inside the LegacyVulnApiResultExtra_LicensesPolicy as the provided LegacyVulnApiResultExtraLicensesPolicy1
func (t *LegacyVulnApiResultExtra_LicensesPolicy) FromLegacyVulnApiResultExtraLicensesPolicy1(v LegacyVulnApiResultExtraLicensesPolicy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyVulnApiResultExtraLicensesPolicy1 performs a merge with any union data inside the LegacyVulnApiResultExtra_LicensesPolicy, using the provided LegacyVulnApiResultExtraLicensesPolicy1
func (t *LegacyVulnApiResultExtra_LicensesPolicy) MergeLegacyVulnApiResultExtraLicensesPolicy1(v LegacyVulnApiResultExtraLicensesPolicy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LegacyVulnApiResultExtra_LicensesPolicy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegacyVulnApiResultExtra_LicensesPolicy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGitTarget returns the union data inside the ScanResult_Target as a GitTarget
func (t ScanResult_Target) AsGitTarget() (GitTarget, error) {
	var body GitTarget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGitTarget overwrites any union data inside the ScanResult_Target as the provided GitTarget
func (t *ScanResult_Target) FromGitTarget(v GitTarget) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGitTarget performs a merge with any union data inside the ScanResult_Target, using the provided GitTarget
func (t *ScanResult_Target) MergeGitTarget(v GitTarget) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerTarget returns the union data inside the ScanResult_Target as a ContainerTarget
func (t ScanResult_Target) AsContainerTarget() (ContainerTarget, error) {
	var body ContainerTarget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerTarget overwrites any union data inside the ScanResult_Target as the provided ContainerTarget
func (t *ScanResult_Target) FromContainerTarget(v ContainerTarget) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerTarget performs a merge with any union data inside the ScanResult_Target, using the provided ContainerTarget
func (t *ScanResult_Target) MergeContainerTarget(v ContainerTarget) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNamedTarget returns the union data inside the ScanResult_Target as a NamedTarget
func (t ScanResult_Target) AsNamedTarget() (NamedTarget, error) {
	var body NamedTarget
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNamedTarget overwrites any union data inside the ScanResult_Target as the provided NamedTarget
func (t *ScanResult_Target) FromNamedTarget(v NamedTarget) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNamedTarget performs a merge with any union data inside the ScanResult_Target, using the provided NamedTarget
func (t *ScanResult_Target) MergeNamedTarget(v NamedTarget) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScanResult_Target) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScanResult_Target) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIacProjectTypes returns the union data inside the SupportedProjectTypes as a IacProjectTypes
func (t SupportedProjectTypes) AsIacProjectTypes() (IacProjectTypes, error) {
	var body IacProjectTypes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIacProjectTypes overwrites any union data inside the SupportedProjectTypes as the provided IacProjectTypes
func (t *SupportedProjectTypes) FromIacProjectTypes(v IacProjectTypes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIacProjectTypes performs a merge with any union data inside the SupportedProjectTypes, using the provided IacProjectTypes
func (t *SupportedProjectTypes) MergeIacProjectTypes(v IacProjectTypes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSupportedPackageManagers returns the union data inside the SupportedProjectTypes as a SupportedPackageManagers
func (t SupportedProjectTypes) AsSupportedPackageManagers() (SupportedPackageManagers, error) {
	var body SupportedPackageManagers
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSupportedPackageManagers overwrites any union data inside the SupportedProjectTypes as the provided SupportedPackageManagers
func (t *SupportedProjectTypes) FromSupportedPackageManagers(v SupportedPackageManagers) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSupportedPackageManagers performs a merge with any union data inside the SupportedProjectTypes, using the provided SupportedPackageManagers
func (t *SupportedProjectTypes) MergeSupportedPackageManagers(v SupportedPackageManagers) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SupportedProjectTypes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SupportedProjectTypes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDepsFilePaths returns the union data inside the TestDependenciesResult_DepsFilePaths as a DepsFilePaths
func (t TestDependenciesResult_DepsFilePaths) AsDepsFilePaths() (DepsFilePaths, error) {
	var body DepsFilePaths
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDepsFilePaths overwrites any union data inside the TestDependenciesResult_DepsFilePaths as the provided DepsFilePaths
func (t *TestDependenciesResult_DepsFilePaths) FromDepsFilePaths(v DepsFilePaths) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDepsFilePaths performs a merge with any union data inside the TestDependenciesResult_DepsFilePaths, using the provided DepsFilePaths
func (t *TestDependenciesResult_DepsFilePaths) MergeDepsFilePaths(v DepsFilePaths) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTestDependenciesResultDepsFilePaths1 returns the union data inside the TestDependenciesResult_DepsFilePaths as a TestDependenciesResultDepsFilePaths1
func (t TestDependenciesResult_DepsFilePaths) AsTestDependenciesResultDepsFilePaths1() (TestDependenciesResultDepsFilePaths1, error) {
	var body TestDependenciesResultDepsFilePaths1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTestDependenciesResultDepsFilePaths1 overwrites any union data inside the TestDependenciesResult_DepsFilePaths as the provided TestDependenciesResultDepsFilePaths1
func (t *TestDependenciesResult_DepsFilePaths) FromTestDependenciesResultDepsFilePaths1(v TestDependenciesResultDepsFilePaths1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTestDependenciesResultDepsFilePaths1 performs a merge with any union data inside the TestDependenciesResult_DepsFilePaths, using the provided TestDependenciesResultDepsFilePaths1
func (t *TestDependenciesResult_DepsFilePaths) MergeTestDependenciesResultDepsFilePaths1(v TestDependenciesResultDepsFilePaths1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TestDependenciesResult_DepsFilePaths) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TestDependenciesResult_DepsFilePaths) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIgnoreSettings returns the union data inside the TestResult_IgnoreSettings as a IgnoreSettings
func (t TestResult_IgnoreSettings) AsIgnoreSettings() (IgnoreSettings, error) {
	var body IgnoreSettings
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnoreSettings overwrites any union data inside the TestResult_IgnoreSettings as the provided IgnoreSettings
func (t *TestResult_IgnoreSettings) FromIgnoreSettings(v IgnoreSettings) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnoreSettings performs a merge with any union data inside the TestResult_IgnoreSettings, using the provided IgnoreSettings
func (t *TestResult_IgnoreSettings) MergeIgnoreSettings(v IgnoreSettings) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTestResultIgnoreSettings1 returns the union data inside the TestResult_IgnoreSettings as a TestResultIgnoreSettings1
func (t TestResult_IgnoreSettings) AsTestResultIgnoreSettings1() (TestResultIgnoreSettings1, error) {
	var body TestResultIgnoreSettings1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTestResultIgnoreSettings1 overwrites any union data inside the TestResult_IgnoreSettings as the provided TestResultIgnoreSettings1
func (t *TestResult_IgnoreSettings) FromTestResultIgnoreSettings1(v TestResultIgnoreSettings1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTestResultIgnoreSettings1 performs a merge with any union data inside the TestResult_IgnoreSettings, using the provided TestResultIgnoreSettings1
func (t *TestResult_IgnoreSettings) MergeTestResultIgnoreSettings1(v TestResultIgnoreSettings1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TestResult_IgnoreSettings) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TestResult_IgnoreSettings) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTestResultLicensesPolicy0 returns the union data inside the TestResult_LicensesPolicy as a TestResultLicensesPolicy0
func (t TestResult_LicensesPolicy) AsTestResultLicensesPolicy0() (TestResultLicensesPolicy0, error) {
	var body TestResultLicensesPolicy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTestResultLicensesPolicy0 overwrites any union data inside the TestResult_LicensesPolicy as the provided TestResultLicensesPolicy0
func (t *TestResult_LicensesPolicy) FromTestResultLicensesPolicy0(v TestResultLicensesPolicy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTestResultLicensesPolicy0 performs a merge with any union data inside the TestResult_LicensesPolicy, using the provided TestResultLicensesPolicy0
func (t *TestResult_LicensesPolicy) MergeTestResultLicensesPolicy0(v TestResultLicensesPolicy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTestResultLicensesPolicy1 returns the union data inside the TestResult_LicensesPolicy as a TestResultLicensesPolicy1
func (t TestResult_LicensesPolicy) AsTestResultLicensesPolicy1() (TestResultLicensesPolicy1, error) {
	var body TestResultLicensesPolicy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTestResultLicensesPolicy1 overwrites any union data inside the TestResult_LicensesPolicy as the provided TestResultLicensesPolicy1
func (t *TestResult_LicensesPolicy) FromTestResultLicensesPolicy1(v TestResultLicensesPolicy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTestResultLicensesPolicy1 performs a merge with any union data inside the TestResult_LicensesPolicy, using the provided TestResultLicensesPolicy1
func (t *TestResult_LicensesPolicy) MergeTestResultLicensesPolicy1(v TestResultLicensesPolicy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TestResult_LicensesPolicy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TestResult_LicensesPolicy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
