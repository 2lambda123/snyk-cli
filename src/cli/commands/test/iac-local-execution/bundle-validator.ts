import * as fs from 'fs';
import * as path from 'path';
import * as jwt from 'jsonwebtoken';
const tls = require('tls');
import { pki } from 'node-forge';
import { createHash } from 'crypto';

import { IaCErrorCodes } from './types';
import { CustomError } from '../../../../lib/errors';

export function validateBundleIntegrity(
  signaturesPath: string,
  certPath: string,
  policyWASMPath: string,
  dataJSONPath: string,
): void {
  console.log('VERIFYING THE BUNDLE INTEGRITY');
  const certPEM = fs.readFileSync(certPath).toString();

  if (!isCertificateTrusted(certPEM)) {
    console.log('CERTIFICATE NOT TRUSTED BY ROOT CA');
    // TODO: better error?
    throw new FailedToValidateBundleIntegrity();
  }
  console.log('CERTIFICATE IS TRUSTED BY ROOT CA');

  const policySignatures = fs.readFileSync(signaturesPath);
  const policySignaturesAsJson: Record<string, any> = JSON.parse(
    policySignatures.toString(),
  );

  const signature = policySignaturesAsJson.signatures?.[0];
  if (!signature) {
    // TODO: better error?
    console.log('SIGNATURE DOES NOT EXIST');
    throw new FailedToValidateBundleIntegrity();
  }

  let decodedSignature: Record<string, any>;
  try {
    decodedSignature = decodeSignatureUsingTrustedCertificate(
      signature,
      certPEM,
    );
    console.log('SIGNATURE WAS GENERATED BY TRUSTED CERTIFICATE');
  } catch (e) {
    // TODO: better error?
    console.log('SIGNATURE WAS NOT GENERATED BY THE TRUSTED CERTIFICATE');
    throw new FailedToValidateBundleIntegrity();
  }
  if (
    !verifyChecksum(policyWASMPath, decodedSignature) ||
    !verifyChecksum(dataJSONPath, decodedSignature)
  ) {
    console.log('CHECKSUMS NOT EQUAL');
    // TODO: better error?
    throw new FailedToValidateBundleIntegrity();
  }
  console.log('CHECKSUMS ARE EQUAL');
}

function isCertificateTrusted(certPEM: string): boolean {
  // TODO: temporary hack for including the CA certificate
  const ca = fs.readFileSync(`${process.cwd()}/ssCerts/ca.crt`).toString();
  const trustedCAs = [...tls.rootCertificates, ca];
  // TODO: end temporary hack for including the CA certificate
  // const trustedCAs = tls.rootCertificates;

  return trustedCAs.some((caCert) => {
    try {
      const caStore = pki.createCaStore([caCert]);
      const cert = pki.certificateFromPem(certPEM);
      pki.verifyCertificateChain(caStore, [cert]);
    } catch (e) {
      return false;
    }
    return true;
  });
}

// TODO: better type
function decodeSignatureUsingTrustedCertificate(
  encodedToken: string,
  certPEM: string,
): Record<any, string> {
  const cert = pki.certificateFromPem(certPEM);
  const publicKey = pki.publicKeyToPem(cert.publicKey);
  return jwt.verify(encodedToken, publicKey);
}

// TODO: better type
function verifyChecksum(
  filePath: string,
  decodedSignature: Record<string, any>,
) {
  const fileName = path.basename(filePath);
  const checksums = decodedSignature.files || [];

  for (const checksum of checksums) {
    if (checksum.name.includes(fileName)) {
      const expectedHash = checksum.hash;

      // TODO: move this to a global variable
      const iacPath: fs.PathLike = path.join('.iac-data/');
      try {
        const fileContents = fs.readFileSync(path.join(iacPath, fileName));
        const actualHash = createHash('sha256')
          .update(fileContents)
          .digest('hex');
        return expectedHash === actualHash;
      } catch {
        console.log('FAILED TO COMPUTE CHECKSUM OF FILE ' + fileName);
      }
    }
  }

  console.log('HAVE NOT FOUND THE FILE');
  return false;
}
export class FailedToValidateBundleIntegrity extends CustomError {
  constructor(message?: string) {
    super(message || 'Failed to validate bundle integrity');
    this.code = IaCErrorCodes.FailedToValidateBundleIntegrity;
    this.userMessage =
      'We were unable validate the integrity of the WASM bundle.';
  }
}
